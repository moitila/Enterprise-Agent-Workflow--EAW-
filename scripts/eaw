#!/usr/bin/env bash
set -euo pipefail

# Error handling: trap ERR to show file, function, line, command
set -E
on_err() {
	local exit_code=$?
	local cmd="${BASH_COMMAND}"
	local src="${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}"
	local fn="${FUNCNAME[1]:-main}"
	local line="${BASH_LINENO[0]:-0}"

	printf "EAW_ERROR: exit=%d at %s:%s:%d cmd: %s\n" \
		"$exit_code" "${src##*/}" "$fn" "$line" "$cmd" >&2

	exit "$exit_code"
}
trap on_err ERR

# Simple CLI for EAW
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
LIB="$SCRIPT_DIR/lib.sh"

if [[ -f "$LIB" ]]; then
	# shellcheck disable=SC1090
	source "$LIB"
else
	echo "Missing library $LIB" >&2
	exit 1
fi

resolve_workdirs "$ROOT_DIR"

CONFIG_DIR="$EAW_CONFIG_DIR"
REPOS_CONF="$CONFIG_DIR/repos.conf"
SEARCH_CONF="$CONFIG_DIR/search.conf"
EAW_CONF="$CONFIG_DIR/eaw.conf"
REQUIRED_CONFIG_VERSION=1

usage() {
	cat <<EOF
Usage: eaw init [--workdir <path>] [--force] [--upgrade]
Example:
  eaw init --workdir ./.eaw --upgrade
  eaw feature <CARD> "<TITLE>"
  eaw spike  <CARD> "<TITLE>"
  eaw bug    <CARD> "<TITLE>"
  eaw prompt <CARD>
  eaw analyze <CARD>
  eaw ingest <CARD> <file-path>
  eaw validate
  eaw doctor
EOF
}

read_config_version() {
	local conf="$1"
	if [[ ! -f "$conf" ]]; then
		return 1
	fi
	local v
	v=$(awk -F'=' '/^[[:space:]]*config_version[[:space:]]*=/{gsub(/[[:space:]]/, "", $2); print $2; exit}' "$conf")
	if [[ -n "$v" ]]; then
		printf "%s\n" "$v"
		return 0
	fi
	return 1
}

check_config_version_validate() {
	local warnings_ref="$1"
	if [[ ! -f "$EAW_CONF" ]]; then
		echo "WARNING: $EAW_CONF missing, assuming v1 defaults"
		eval "$warnings_ref=\$(( $warnings_ref + 1 ))"
		return 0
	fi

	local cv
	if cv="$(read_config_version "$EAW_CONF")"; then
		if [[ "$cv" =~ ^[0-9]+$ ]] && [[ "$cv" -lt "$REQUIRED_CONFIG_VERSION" ]]; then
			if [[ -n "${EAW_WORKDIR:-}" ]]; then
				echo "WARNING: config_version=$cv is older than required=$REQUIRED_CONFIG_VERSION; run: ./scripts/eaw init --workdir \"$EAW_WORKDIR\" --upgrade"
			else
				echo "WARNING: config_version=$cv is older than required=$REQUIRED_CONFIG_VERSION; update $EAW_CONF"
			fi
			eval "$warnings_ref=\$(( $warnings_ref + 1 ))"
		fi
	else
		echo "WARNING: $EAW_CONF exists but config_version is missing; add: config_version=$REQUIRED_CONFIG_VERSION"
		eval "$warnings_ref=\$(( $warnings_ref + 1 ))"
	fi
}

cmd_init() {
	local force="false"
	local workdir=""
	local upgrade="false"
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--workdir)
			shift
			if [[ $# -lt 1 || -z "${1:-}" ]]; then
				echo "Missing value for --workdir" >&2
				exit 1
			fi
			workdir="$1"
			;;
		--force)
			force="true"
			;;
		--upgrade)
			upgrade="true"
			;;
		*)
			echo "Unknown init option: $1" >&2
			usage
			exit 1
			;;
		esac
		shift
	done

	if [[ -n "$workdir" ]]; then
		init_workspace_workdir "$workdir" "$force" "$upgrade"
		return 0
	fi

	if [[ "$upgrade" == "true" ]]; then
		echo "--upgrade requires --workdir <path>" >&2
		exit 1
	fi

	ensure_dir "$CONFIG_DIR"
	if [[ -f "$SCRIPT_DIR/sync-repos-config.sh" ]]; then
		bash "$SCRIPT_DIR/sync-repos-config.sh"
	else
		if [[ ! -f "$REPOS_CONF" ]]; then
			cp "$CONFIG_DIR/repos.example.conf" "$REPOS_CONF"
			echo "Created $REPOS_CONF"
		else
			echo "$REPOS_CONF already exists; skipping"
		fi
	fi
	if [[ ! -f "$SEARCH_CONF" ]]; then
		cp "$CONFIG_DIR/search.example.conf" "$SEARCH_CONF"
		echo "Created $SEARCH_CONF"
	else
		echo "$SEARCH_CONF already exists; skipping"
	fi
}

write_or_skip() {
	local target="$1"
	local force="$2"
	local content="$3"
	if [[ -f "$target" && "$force" != "true" ]]; then
		echo "$target already exists; use --force to overwrite"
		return 0
	fi
	printf "%s\n" "$content" >"$target"
	echo "Created $target"
}

write_eaw_conf_if_needed() {
	local cfg="$1"
	local workdir="$2"
	local force="$3"
	local upgrade="$4"
	local conf="$cfg/eaw.conf"
	local new_conf="$cfg/eaw.conf.new"

	if [[ ! -f "$conf" ]]; then
		printf "config_version=%s\n" "$REQUIRED_CONFIG_VERSION" >"$conf"
		echo "Created $conf"
		return 0
	fi

	local current_v
	if current_v="$(read_config_version "$conf")"; then
		if [[ "$current_v" =~ ^[0-9]+$ ]] && [[ "$current_v" -lt "$REQUIRED_CONFIG_VERSION" ]] && [[ "$upgrade" == "true" ]]; then
			printf "config_version=%s\n" "$REQUIRED_CONFIG_VERSION" >"$new_conf"
			echo "$conf has older config_version=$current_v; wrote upgrade hint to $new_conf"
		fi
	else
		if [[ "$upgrade" == "true" ]]; then
			printf "config_version=%s\n" "$REQUIRED_CONFIG_VERSION" >"$new_conf"
			echo "$conf is missing config_version; wrote $new_conf"
		else
			echo "$conf exists but config_version is missing; run: ./scripts/eaw init --workdir \"$workdir\" --upgrade"
		fi
	fi

	if [[ "$force" == "true" ]]; then
		printf "config_version=%s\n" "$REQUIRED_CONFIG_VERSION" >"$conf"
		echo "Created $conf"
	fi
}

init_workspace_workdir() {
	local workdir="$1"
	local force="$2"
	local upgrade="$3"
	local cfg="$workdir/config"
	local tpl="$workdir/templates"
	local out="$workdir/out"
	local repos_conf="$cfg/repos.conf"
	local search_conf="$cfg/search.conf"
	local default_search="$EAW_ROOT_DIR/config/search.example.conf"
	local default_tpl_dir="$EAW_ROOT_DIR/templates"

	ensure_dir "$cfg"
	ensure_dir "$tpl"
	ensure_dir "$out"

	write_or_skip "$repos_conf" "$force" "# Format: key|path
# Example:
# backend|/absolute/path/to/repo"

	for name in feature bug spike intake_feature intake_bug intake_spike; do
		local src_tpl="$default_tpl_dir/$name.md"
		local dst_tpl="$tpl/$name.md"
		if [[ -f "$src_tpl" ]]; then
			if [[ -f "$dst_tpl" && "$force" != "true" ]]; then
				echo "$dst_tpl already exists; use --force to overwrite"
			else
				cp "$src_tpl" "$dst_tpl"
				echo "Created $dst_tpl"
			fi
		fi
	done

	if [[ -f "$default_search" ]]; then
		if [[ -f "$search_conf" && "$force" != "true" ]]; then
			echo "$search_conf already exists; use --force to overwrite"
		else
			cp "$default_search" "$search_conf"
			echo "Created $search_conf"
		fi
	else
		write_or_skip "$search_conf" "$force" "# Add one search pattern per line
# Example:
# TODO|FIXME"
	fi

	write_eaw_conf_if_needed "$cfg" "$workdir" "$force" "$upgrade"
}

validate_runtime_workdir() {
	if [[ -n "${EAW_WORKDIR:-}" ]]; then
		if [[ ! -d "$EAW_CONFIG_DIR" || ! -f "$REPOS_CONF" ]]; then
			echo "EAW_WORKDIR is set but workspace config is incomplete." >&2
			echo "Run:" >&2
			echo "  ./scripts/eaw init --workdir \"$EAW_WORKDIR\"" >&2
			exit 1
		fi
	fi
}

trim_spaces() {
	local s="$1"
	s="${s#"${s%%[![:space:]]*}"}"
	s="${s%"${s##*[![:space:]]}"}"
	printf "%s\n" "$s"
}

cmd_validate() {
	local errors=0
	local warnings=0
	local line lineno key path extra resolved_path

	echo "EAW validate"
	echo "Resolved dirs:"
	echo "  EAW_ROOT_DIR=$EAW_ROOT_DIR"
	echo "  EAW_WORKDIR=${EAW_WORKDIR:-}"
	echo "  EAW_CONFIG_DIR=$EAW_CONFIG_DIR"
	echo "  EAW_TEMPLATES_DIR=$EAW_TEMPLATES_DIR"
	echo "  EAW_OUT_DIR=$EAW_OUT_DIR"

	if [[ -n "${EAW_WORKDIR:-}" ]]; then
		if [[ ! -d "$EAW_CONFIG_DIR" ]]; then
			echo "ERROR: workspace config directory missing: $EAW_CONFIG_DIR"
			errors=$((errors + 1))
		fi
		if [[ ! -f "$REPOS_CONF" ]]; then
			echo "ERROR: workspace repos.conf missing: $REPOS_CONF"
			errors=$((errors + 1))
		fi
	fi

	check_config_version_validate warnings

	if [[ -f "$REPOS_CONF" ]]; then
		lineno=0
		while IFS= read -r line; do
			lineno=$((lineno + 1))
			line="${line//$'\r'/}"
			if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
				continue
			fi
			if [[ "$line" != *"|"* ]]; then
				echo "ERROR: repos.conf:$lineno invalid format (expected key|path): $line"
				errors=$((errors + 1))
				continue
			fi
			IFS='|' read -r key path extra <<<"$line"
			key="$(trim_spaces "$key")"
			path="$(trim_spaces "$path")"
			if [[ -n "${extra:-}" ]]; then
				echo "ERROR: repos.conf:$lineno invalid format (too many '|'): $line"
				errors=$((errors + 1))
				continue
			fi
			if [[ -z "$key" || -z "$path" ]]; then
				echo "ERROR: repos.conf:$lineno key/path cannot be empty: $line"
				errors=$((errors + 1))
				continue
			fi
			resolved_path="$(resolve_repo_path "$path")"
			if [[ ! -e "$resolved_path" ]]; then
				echo "WARNING: repos.conf:$lineno path does not exist: $resolved_path"
				warnings=$((warnings + 1))
			fi
		done <"$REPOS_CONF"
		echo "OK: repos.conf parsed"
	else
		echo "WARNING: repos.conf missing: $REPOS_CONF"
		warnings=$((warnings + 1))
	fi

	if [[ -f "$SEARCH_CONF" ]]; then
		echo "OK: search.conf found: $SEARCH_CONF"
	else
		echo "WARNING: search.conf missing: $SEARCH_CONF"
		warnings=$((warnings + 1))
	fi

	if [[ -n "${EAW_WORKDIR:-}" && -d "$EAW_WORKDIR/templates" ]]; then
		for tpl_name in feature.md bug.md spike.md intake_bug.md intake_feature.md intake_spike.md; do
			if [[ ! -r "$EAW_WORKDIR/templates/$tpl_name" ]]; then
				echo "WARNING: missing or unreadable workspace template: $EAW_WORKDIR/templates/$tpl_name"
				warnings=$((warnings + 1))
			fi
		done
	fi

	local intake_bug_tpl="$EAW_TEMPLATES_DIR/intake_bug.md"
	local intake_feature_tpl="$EAW_TEMPLATES_DIR/intake_feature.md"
	local intake_spike_tpl="$EAW_TEMPLATES_DIR/intake_spike.md"

	if [[ ! -r "$intake_bug_tpl" ]]; then
		echo "WARNING: templates/intake_bug.md missing"
		warnings=$((warnings + 1))
	else
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*(Resumo do problema|Resumo)[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Resumo do problema ou Resumo"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*Comportamento esperado[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Comportamento esperado"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*Comportamento atual[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Comportamento atual"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*Passos para reproduzir[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Passos para reproduzir"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*Evidências fornecidas[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Evidências fornecidas"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*Impacto[[:space:]]*/[[:space:]]*Escopo[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Impacto / Escopo"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*Perguntas em aberto[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Perguntas em aberto"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_bug_tpl" '^##[[:space:]]*Hipóteses iniciais[[:space:]]*$'; then
			echo "WARNING: templates/intake_bug.md missing heading: Hipóteses iniciais"
			warnings=$((warnings + 1))
		fi
	fi

	if [[ ! -r "$intake_feature_tpl" ]]; then
		echo "WARNING: templates/intake_feature.md missing"
		warnings=$((warnings + 1))
	else
		if ! grep_heading_match "$intake_feature_tpl" '^##[[:space:]]*Problema[[:space:]]*$'; then
			echo "WARNING: templates/intake_feature.md missing heading: Problema"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_feature_tpl" '^##[[:space:]]*Objetivo[[:space:]]*$'; then
			echo "WARNING: templates/intake_feature.md missing heading: Objetivo"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_feature_tpl" '^##[[:space:]]*Critérios de aceite[[:space:]]*$'; then
			echo "WARNING: templates/intake_feature.md missing heading: Critérios de aceite"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_feature_tpl" '^##[[:space:]]*Escopo[[:space:]]*\(In/Out\)[[:space:]]*$'; then
			echo "WARNING: templates/intake_feature.md missing heading: Escopo (In/Out)"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_feature_tpl" '^##[[:space:]]*Dependências[[:space:]]*$'; then
			echo "WARNING: templates/intake_feature.md missing heading: Dependências"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_feature_tpl" '^##[[:space:]]*Riscos[[:space:]]*$'; then
			echo "WARNING: templates/intake_feature.md missing heading: Riscos"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_feature_tpl" '^##[[:space:]]*Perguntas em aberto[[:space:]]*$'; then
			echo "WARNING: templates/intake_feature.md missing heading: Perguntas em aberto"
			warnings=$((warnings + 1))
		fi
	fi

	if [[ ! -r "$intake_spike_tpl" ]]; then
		echo "WARNING: templates/intake_spike.md missing"
		warnings=$((warnings + 1))
	else
		if ! grep_heading_match "$intake_spike_tpl" '^##[[:space:]]*Pergunta[[:space:]]*/[[:space:]]*Hipótese[[:space:]]*$'; then
			echo "WARNING: templates/intake_spike.md missing heading: Pergunta / Hipótese"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_spike_tpl" '^##[[:space:]]*Contexto técnico[[:space:]]*$'; then
			echo "WARNING: templates/intake_spike.md missing heading: Contexto técnico"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_spike_tpl" '^##[[:space:]]*Opções consideradas[[:space:]]*$'; then
			echo "WARNING: templates/intake_spike.md missing heading: Opções consideradas"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_spike_tpl" '^##[[:space:]]*Critério de conclusão[[:space:]]*$'; then
			echo "WARNING: templates/intake_spike.md missing heading: Critério de conclusão"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_spike_tpl" '^##[[:space:]]*Riscos[[:space:]]*$'; then
			echo "WARNING: templates/intake_spike.md missing heading: Riscos"
			warnings=$((warnings + 1))
		fi
		if ! grep_heading_match "$intake_spike_tpl" '^##[[:space:]]*Próximos passos[[:space:]]*$'; then
			echo "WARNING: templates/intake_spike.md missing heading: Próximos passos"
			warnings=$((warnings + 1))
		fi
	fi

	echo "SUMMARY: errors=$errors warnings=$warnings"
	if [[ "$errors" -gt 0 ]]; then
		return 2
	fi
	return 0
}

cmd_doctor() {
	local warnings=0
	local errors=0
	local status="OK"
	local config_version=""

	echo "EAW doctor"
	echo "Resolved dirs:"
	echo "  EAW_ROOT_DIR=$EAW_ROOT_DIR"
	echo "  EAW_WORKDIR=${EAW_WORKDIR:-}"
	echo "  EAW_CONFIG_DIR=$EAW_CONFIG_DIR"
	echo "  EAW_TEMPLATES_DIR=$EAW_TEMPLATES_DIR"
	echo "  EAW_OUT_DIR=$EAW_OUT_DIR"

	echo "Tools:"
	if command -v git >/dev/null 2>&1; then echo "  git: OK"; else
		echo "  git: MISSING"
		warnings=$((warnings + 1))
	fi
	if command -v rg >/dev/null 2>&1; then
		echo "  rg: OK"
	elif command -v grep >/dev/null 2>&1; then
		echo "  rg: MISSING (grep fallback: OK)"
		warnings=$((warnings + 1))
	else
		echo "  rg/grep: MISSING"
		errors=$((errors + 1))
	fi
	if command -v awk >/dev/null 2>&1; then echo "  awk: OK"; else
		echo "  awk: MISSING"
		errors=$((errors + 1))
	fi
	if command -v sed >/dev/null 2>&1; then echo "  sed: OK"; else
		echo "  sed: MISSING"
		errors=$((errors + 1))
	fi
	echo "  bash: $(bash --version | head -n 1)"

	echo "Files:"
	if [[ -f "$REPOS_CONF" ]]; then echo "  repos.conf: OK ($REPOS_CONF)"; else
		echo "  repos.conf: MISSING ($REPOS_CONF)"
		[[ -n "${EAW_WORKDIR:-}" ]] && errors=$((errors + 1)) || warnings=$((warnings + 1))
	fi
	if [[ -f "$SEARCH_CONF" ]]; then echo "  search.conf: OK ($SEARCH_CONF)"; else
		echo "  search.conf: MISSING ($SEARCH_CONF)"
		warnings=$((warnings + 1))
	fi
	if [[ -f "$EAW_CONF" ]]; then
		if config_version="$(read_config_version "$EAW_CONF")"; then
			echo "  eaw.conf: OK ($EAW_CONF, config_version=$config_version)"
		else
			echo "  eaw.conf: WARN ($EAW_CONF, config_version missing)"
			warnings=$((warnings + 1))
		fi
	else
		echo "  eaw.conf: MISSING ($EAW_CONF)"
		warnings=$((warnings + 1))
	fi

	if [[ "$errors" -gt 0 ]]; then
		status="ERROR"
	elif [[ "$warnings" -gt 0 ]]; then
		status="WARN"
	fi
	echo "STATUS: $status (errors=$errors warnings=$warnings)"
	return 0
}

# --- Execution lifecycle engine -------------------------------------------------
run_phase() {
	# run_phase <phase-name> <fatal:true|false> <fn> [args...]
	local phase="$1"
	shift
	local fatal="$1"
	shift || true
	local fn="$1"
	shift
	local start end dur rc status
	local note=""
	start=$(date +%s%3N)
	if "$fn" "$@"; then
		rc=0
		status="OK"
	else
		rc=$?
		status="FAIL"
	fi
	end=$(date +%s%3N)
	dur=$((end - start))
	# record to execution log
	printf "%s|%s|%s|%s\n" "$phase" "$status" "$dur" "$note" >>"$OUTDIR/execution.log"
	# print summary line
	echo "[phase] $phase -> $status (${dur}ms)"
	if [[ "$status" != "OK" && "$fatal" == "true" ]]; then
		echo "phase '$phase' failed (fatal) with rc=$rc" >&2
		return "$rc"
	fi
	return 0
}

phase_init_runtime() {
	# $1 = type, $2 = card, $3 = title, $4 = outdir
	local type="$1" card="$2" title="$3" outdir="$4"
	# deterministic runtime for phases
	export LC_ALL=C
	export TZ=UTC
	ensure_dir "$outdir"
	local tpl
	tpl="$EAW_TEMPLATES_DIR/$(echo "$type" | tr '[:upper:]' '[:lower:]').md"
	if [[ ! -f "$tpl" ]]; then
		echo "Template not found: $tpl" >&2
		return 1
	fi
	local date
	date=$(iso_date)
	local target_md="$outdir/${type}_${card}.md"
	render_template "$tpl" "$target_md" "$card" "$title" "$type" "$date"
	echo "Wrote $target_md"
	local intake_dir="$outdir/investigations"
	local intake_file="$intake_dir/00_intake.md"
	local intake_tpl="$EAW_TEMPLATES_DIR/intake_${type}.md"
	ensure_dir "$intake_dir"
	if [[ ! -f "$intake_file" ]]; then
		if [[ -f "$intake_tpl" ]]; then
			cp "$intake_tpl" "$intake_file"
		else
			echo "WARNING: missing intake template for type '$type': $intake_tpl; using minimal fallback"
			cat >"$intake_file" <<EOF
# Intake ${type^^} ${card}

## Resumo

## Comportamento esperado

## Comportamento atual

## Passos para reproduzir
EOF
		fi
		echo "Wrote $intake_file"
	fi
	# initialize execution.log
	: >"$outdir/execution.log"
	printf "phase|status|duration_ms|note\n" >>"$outdir/execution.log"
	return 0
}

phase_load_config() {
	# verify minimal config presence; not fatal if repos.conf missing (best-effort)
	local outdir="$1"
	if [[ ! -f "$REPOS_CONF" ]]; then
		echo "Missing $REPOS_CONF; proceeding without repository context (best-effort)" >&2
		return 0
	fi
	return 0
}

phase_resolve_repos() {
	# build list of repo entries (key|path) into REPO_ENTRIES array
	REPO_ENTRIES=()
	if [[ -f "$REPOS_CONF" ]]; then
		while IFS= read -r line; do
			line="${line//$'\r'/}"
			if [[ -z "$line" || "$line" =~ ^\s*# ]]; then
				continue
			fi
			REPO_ENTRIES+=("$line")
		done <"$REPOS_CONF"
	fi
	return 0
}

phase_collect_context() {
	local card="$1" outdir="$2"
	# iterate resolved repos and gather context
	for entry in "${REPO_ENTRIES[@]:-}"; do
		IFS='|' read -r key path <<<"$entry"
		if [[ -z "$key" || -z "$path" ]]; then
			continue
		fi
		repoPath="$(resolve_repo_path "$path")"
		repoOutDir="$outdir/context/$key"
		ensure_dir "$repoOutDir"
		echo "Collecting context for $key -> $repoPath"
		# gather context; failures are tolerated and produce _warnings.txt within gather_context_for_repo
		if ! gather_context_for_repo "$key" "$repoPath" "$repoOutDir"; then
			echo "allowed to fail: gather_context_for_repo failed for $key (see $repoOutDir)" >>"$repoOutDir/_warnings.txt"
		fi
	done
	return 0
}

phase_search_hits() {
	local outdir="$1"
	for entry in "${REPO_ENTRIES[@]:-}"; do
		IFS='|' read -r key path <<<"$entry"
		if [[ -z "$key" || -z "$path" ]]; then
			continue
		fi
		repoPath="$(resolve_repo_path "$path")"
		repoOutDir="$outdir/context/$key"
		if ! collect_search_hits "$key" "$repoPath" "$repoOutDir" "$SEARCH_CONF"; then
			echo "allowed to fail: collect_search_hits failed for $key (see $repoOutDir)" >>"$repoOutDir/_warnings.txt"
		fi
	done
	return 0
}

phase_finalize() {
	local card="$1" outdir="$2"
	# summarize execution.log to stdout
	if [[ -f "$outdir/execution.log" ]]; then
		echo "Execution log for $card:" >&2
		sed -n '1,200p' "$outdir/execution.log" >&2 || true
	fi
	return 0
}

# --- end lifecycle engine ----------------------------------------------------

cmd_card() {
	local type="$1"
	local card="$2"
	local title="$3"
	local outdir="$EAW_OUT_DIR/$card"
	# expose OUTDIR for run_phase and others
	OUTDIR="$outdir"
	ensure_dir "$outdir"

	# run lifecycle phases in order; preserve original behavior and tolerances
	run_phase "init_runtime" true phase_init_runtime "$type" "$card" "$title" "$outdir" || return 1
	run_phase "load_config" false phase_load_config "$outdir"
	run_phase "resolve_repos" false phase_resolve_repos
	run_phase "collect_context" false phase_collect_context "$card" "$outdir"
	run_phase "search_hits" false phase_search_hits "$outdir"
	run_phase "finalize" false phase_finalize "$card" "$outdir"
}

cmd_analyze() {
	local card="$1"
	local outdir="$EAW_OUT_DIR/$card"
	if [[ ! -d "$outdir" ]]; then
		echo "Card output not found: $outdir" >&2
		exit 1
	fi
	# detect type
	local type=""
	for t in feature spike bug; do
		if [[ -f "$outdir/${t}_${card}.md" ]]; then
			type="$t"
			break
		fi
	done
	if [[ -z "$type" ]]; then
		echo "Could not detect card type for $card. Expected feature/spike/bug file in $outdir" >&2
		exit 1
	fi

	local main_md="$outdir/${type}_${card}.md"
	if [[ ! -f "$main_md" ]]; then
		echo "Main dossier not found: $main_md" >&2
		exit 1
	fi

	ensure_dir "$outdir/inputs"

	# Build AI prompt
	local prompt_file="$outdir/AI_PROMPT_${card}.md"
	local date_now
	date_now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

	# collect repos list
	local repos_list
	if [[ -f "$REPOS_CONF" ]]; then
		repos_list=$(awk -F"|" '!/^\s*#/ && NF>=2 {print "- " $1 " => " $2}' "$REPOS_CONF")
	else
		repos_list="(no repos.conf present)"
	fi

	cat >"$prompt_file" <<EOF
# AI_PROMPT for card ${card}

ROLE:
You are a senior engineering analyst assisting with a structured review and mitigation plan for an engineering card. Provide concise, actionable analysis, tests, and a minimal change plan.

GUARDRAILS:
- Do not invent facts. Use only provided inputs and repository context.
- Mark assumptions explicitly.
- Prioritize minimal, safe fixes and clear test plans.

INPUTS:
- Dossier: $main_md
- Context directory: $outdir/context/
- Ingested files: $(ls -1 "$outdir/inputs" 2>/dev/null || echo "(none)")

REPOSITORIES:
$repos_list

PROCESS (mandatory 8 phases):
1) Understanding: Summarize card in 2-3 sentences.
2) Scoping: List affected modules and blast radius.
3) Evidence collection: Enumerate relevant files and diff snippets from context/.
4) Risk mapping: Map hotspots, regression risk, and critical paths.
5) Hypothesis & Proposed Fix: Describe minimal fix or experiment.
6) Test Plan: Provide deterministic tests and validation steps; produce TEST_PLAN file in dev/ (see Outputs).
7) Implementation steps: Minimal, atomic changes with rollbacks and feature flags where applicable.
8) Validation & Monitoring: Post-deploy checks, metrics to watch, and rollback criteria.

OUTPUTS (write to dev/ within the dossier output):
- TEST_PLAN_${card}.md - deterministic test plan (unit/integration/smoke)
- PATCH/PR summary (one paragraph)
- RISK_SUMMARY (one paragraph)

ALLOWED QUESTIONS (ask only when missing info):
- Are there existing failing tests related to this area?
- Is there any sensitive data or compliance constraint for changes?
- Any required stakeholders to involve?

Date generated: $date_now

-- Dossier content (begin) --

$(sed -n '1,400p' "$main_md")

-- Dossier content (end) --

EOF

	echo "Wrote $prompt_file"

	# create TEST_PLAN placeholder in outdir
	local test_plan="$outdir/TEST_PLAN_${card}.md"
	if [[ ! -f "$test_plan" ]]; then
		cat >"$test_plan" <<TP
# Test Plan for ${type}_${card}

## Summary

Describe deterministic tests to validate changes.

## Unit Tests

- Add tests for ...

## Integration Tests

- Run ...

TP
		echo "Wrote $test_plan"
	fi
}

cmd_ingest() {
	local card="$1"
	local src_path="$2"
	local outdir="$EAW_OUT_DIR/$card"
	if [[ ! -f "$src_path" ]]; then
		echo "Source file not found: $src_path" >&2
		exit 1
	fi
	ensure_dir "$outdir/inputs"
	local fname
	fname=$(basename "$src_path")
	cp "$src_path" "$outdir/inputs/"
	echo "Copied $src_path -> $outdir/inputs/$fname"

	# update main dossier
	# detect type and main md
	local type=""
	for t in feature spike bug; do
		if [[ -f "$outdir/${t}_${card}.md" ]]; then
			type="$t"
			break
		fi
	done
	if [[ -z "$type" ]]; then
		echo "Cannot find main dossier to attach evidence: expected ${type}_${card}.md" >&2
		exit 1
	fi
	local main_md="$outdir/${type}_${card}.md"
	local ts
	ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)

	# insert or append Attached Evidence section
	if grep -q "^## Attached Evidence" "$main_md"; then
		# append bullet
		printf "- %s - %s\n" "$fname" "$ts" >>"$main_md"
	else
		printf "\n## Attached Evidence\n- %s - %s\n" "$fname" "$ts" >>"$main_md"
	fi
	echo "Registered evidence in $main_md"
}

append_warn() {
	local warn_ref="$1"
	local msg="$2"
	eval "$warn_ref+=(\"\$msg\")"
}

grep_heading_match() {
	local file="$1"
	local pattern="$2"
	if command -v rg >/dev/null 2>&1; then
		rg -i -q -- "$pattern" "$file"
	else
		grep -Eiq -- "$pattern" "$file"
	fi
}

validate_intake_heading_group() {
	local file="$1"
	local warn_ref="$2"
	local label="$3"
	local pattern="$4"
	if ! grep_heading_match "$file" "$pattern"; then
		append_warn "$warn_ref" "intake missing heading for '${label}'"
	fi
}

detect_card_type_with_warnings() {
	local card="$1"
	local outdir="$2"
	local type_ref="$3"
	local warn_ref="$4"
	local found=()

	if [[ -f "$outdir/bug_${card}.md" ]]; then
		found+=("bug")
	fi
	if [[ -f "$outdir/feature_${card}.md" ]]; then
		found+=("feature")
	fi
	if [[ -f "$outdir/spike_${card}.md" ]]; then
		found+=("spike")
	fi

	if [[ "${#found[@]}" -eq 0 ]]; then
		append_warn "$warn_ref" "no dossier file found in $outdir; defaulting type to bug"
		eval "$type_ref='bug'"
		return 0
	fi

	if [[ "${#found[@]}" -gt 1 ]]; then
		append_warn "$warn_ref" "ambiguous card type (${found[*]}); applying priority bug > feature > spike"
	fi

	if [[ " ${found[*]} " == *" bug "* ]]; then
		eval "$type_ref='bug'"
		return 0
	fi
	if [[ " ${found[*]} " == *" feature "* ]]; then
		eval "$type_ref='feature'"
		return 0
	fi
	eval "$type_ref='spike'"
}

count_required_intake_headings() {
	local type="$1"
	local file="$2"
	local count=0
	case "$type" in
	bug)
		if grep_heading_match "$file" '^##[[:space:]]*(Resumo do problema|Resumo)[[:space:]]*$'; then count=$((count + 1)); fi
		if grep_heading_match "$file" '^##[[:space:]]*Comportamento esperado[[:space:]]*$'; then count=$((count + 1)); fi
		if grep_heading_match "$file" '^##[[:space:]]*Comportamento atual[[:space:]]*$'; then count=$((count + 1)); fi
		if grep_heading_match "$file" '^##[[:space:]]*Passos para reproduzir[[:space:]]*$'; then count=$((count + 1)); fi
		;;
	feature)
		if grep_heading_match "$file" '^##[[:space:]]*(Problema|Objetivo)[[:space:]]*$'; then count=$((count + 1)); fi
		if grep_heading_match "$file" '^##[[:space:]]*Critérios de aceite[[:space:]]*$'; then count=$((count + 1)); fi
		if grep_heading_match "$file" '^##[[:space:]]*Escopo([[:space:]]*\(In/Out\))?[[:space:]]*$'; then count=$((count + 1)); fi
		;;
	spike)
		if grep_heading_match "$file" '^##[[:space:]]*(Pergunta[[:space:]]*/[[:space:]]*Hipótese|Pergunta|Hipótese)[[:space:]]*$'; then count=$((count + 1)); fi
		if grep_heading_match "$file" '^##[[:space:]]*Critério de conclusão[[:space:]]*$'; then count=$((count + 1)); fi
		;;
	esac
	echo "$count"
}

intake_is_structurally_incomplete() {
	local type="$1"
	local file="$2"
	local size_bytes=0
	local required_hits=0
	size_bytes=$(wc -c <"$file" | tr -d '[:space:]')
	required_hits="$(count_required_intake_headings "$type" "$file")"
	if [[ "$size_bytes" -lt 50 || "$required_hits" -le 1 ]]; then
		return 0
	fi
	return 1
}

intake_has_section_headings() {
	local file="$1"
	if command -v rg >/dev/null 2>&1; then
		rg -q -- '^[[:space:]]*##[[:space:]]+\S' "$file"
	else
		grep -Eq -- '^[[:space:]]*##[[:space:]]+\S' "$file"
	fi
}

cmd_prompt() {
	local card="$1"
	local outdir="$EAW_OUT_DIR/$card"
	local intake_file="$outdir/investigations/00_intake.md"
	local type=""
	local warnings=()

	detect_card_type_with_warnings "$card" "$outdir" type warnings

	if [[ ! -f "$intake_file" ]]; then
		append_warn warnings "missing intake file: $intake_file"
	else
		case "$type" in
		bug)
			validate_intake_heading_group "$intake_file" warnings "Resumo do problema ou Resumo" '^##[[:space:]]*(Resumo do problema|Resumo)[[:space:]]*$'
			validate_intake_heading_group "$intake_file" warnings "Comportamento esperado" '^##[[:space:]]*Comportamento esperado[[:space:]]*$'
			validate_intake_heading_group "$intake_file" warnings "Comportamento atual" '^##[[:space:]]*Comportamento atual[[:space:]]*$'
			validate_intake_heading_group "$intake_file" warnings "Passos para reproduzir" '^##[[:space:]]*Passos para reproduzir[[:space:]]*$'
			;;
		feature)
			validate_intake_heading_group "$intake_file" warnings "Problema ou Objetivo" '^##[[:space:]]*(Problema|Objetivo)[[:space:]]*$'
			validate_intake_heading_group "$intake_file" warnings "Critérios de aceite" '^##[[:space:]]*Critérios de aceite[[:space:]]*$'
			validate_intake_heading_group "$intake_file" warnings "Escopo" '^##[[:space:]]*Escopo([[:space:]]*\(In/Out\))?[[:space:]]*$'
			;;
		spike)
			validate_intake_heading_group "$intake_file" warnings "Pergunta ou Hipótese" '^##[[:space:]]*(Pergunta[[:space:]]*/[[:space:]]*Hipótese|Pergunta|Hipótese)[[:space:]]*$'
			validate_intake_heading_group "$intake_file" warnings "Critério de conclusão" '^##[[:space:]]*Critério de conclusão[[:space:]]*$'
			;;
		esac
		if ! intake_has_section_headings "$intake_file" || intake_is_structurally_incomplete "$type" "$intake_file"; then
			append_warn warnings "intake appears structurally incomplete."
			append_warn warnings "DO NOT START INVESTIGATION BEFORE COMPLETING REQUIRED SECTIONS."
		fi
	fi

	echo "=== EAW AGENT PROMPT (${type}) CARD ${card} ==="
	echo "EAW_WORKDIR=${EAW_WORKDIR:-}"
	echo "OUT_DIR=$outdir"

	for warn in "${warnings[@]}"; do
		if [[ "$warn" == "DO NOT START INVESTIGATION BEFORE COMPLETING REQUIRED SECTIONS." ]]; then
			echo "WARNING: $warn"
		else
			echo "WARN: $warn"
		fi
	done

	cat <<EOF
Você é o agente do VSCode e deve investigar o card ${card} (${type}) com disciplina EAW.

REGRAS OBRIGATÓRIAS:

Não alterar código.

Não commitar.

Toda afirmação deve ter evidência (path real + comando + trecho curto).

Trabalhar exclusivamente dentro de out/${card}/.

Qualquer desvio deve ser registrado em investigations/_warnings.md.

PASSO 1 — BASELINE
export EAW_WORKDIR="${EAW_WORKDIR:-}"
./scripts/eaw doctor
./scripts/eaw validate

PASSO 2 — ARTEFATOS EAW
Confirme existência de:

execution.log

${type}_${card}.md

investigations/00_intake.md
out/${card}/investigations/00_intake.md

PASSO 3 — INVESTIGAÇÃO CONTROLADA

Use apenas contexto de out/${card}/ e código do repo.

Registre comandos e outputs em:
investigations/20_findings.md

PASSO 4 — ATUALIZAR TEMPLATE DO CARD
Atualize:
out/${card}/${type}_${card}.md
com evidências reais coletadas.

PASSO 5 — CONCLUSÃO
Produza:

investigations/40_next_steps.md

diagnóstico fundamentado

riscos

plano mínimo determinístico
EOF
}

main() {
	if [[ $# -lt 1 ]]; then
		usage
		exit 1
	fi
	case "$1" in
	init)
		cmd_init "${@:2}"
		;;
	feature | spike | bug)
		if [[ $# -lt 3 ]]; then
			echo "Missing args" >&2
			usage
			exit 1
		fi
		validate_runtime_workdir
		cmd_card "${1}" "$2" "$3"
		;;
	analyze)
		if [[ $# -lt 2 ]]; then
			echo "Missing args" >&2
			usage
			exit 1
		fi
		validate_runtime_workdir
		cmd_analyze "$2"
		;;
	prompt)
		if [[ $# -lt 2 ]]; then
			echo "Missing args" >&2
			usage
			exit 1
		fi
		validate_runtime_workdir
		cmd_prompt "$2"
		;;
	ingest)
		if [[ $# -lt 3 ]]; then
			echo "Missing args" >&2
			usage
			exit 1
		fi
		validate_runtime_workdir
		cmd_ingest "$2" "$3"
		;;
	validate)
		if cmd_validate; then
			exit 0
		else
			exit $?
		fi
		;;
	doctor)
		cmd_doctor
		;;
	--help | -h)
		usage
		exit 0
		;;
	*)
		usage
		exit 1
		;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
