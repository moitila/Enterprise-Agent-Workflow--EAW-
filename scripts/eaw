#!/usr/bin/env bash
set -euo pipefail

# Error handling: trap ERR to show file, function, line, command
set -E
on_err() {
	local exit_code=$?
	local cmd="${BASH_COMMAND}"
	local src="${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}"
	local fn="${FUNCNAME[1]:-main}"
	local line="${BASH_LINENO[0]:-0}"

	printf "EAW_ERROR: exit=%d at %s:%s:%d cmd: %s\n" \
		"$exit_code" "${src##*/}" "$fn" "$line" "$cmd" >&2

	exit "$exit_code"
}
trap on_err ERR

# Simple CLI for EAW
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
LIB="$SCRIPT_DIR/lib.sh"

if [[ -f "$LIB" ]]; then
	# shellcheck disable=SC1090
	source "$LIB"
else
	echo "Missing library $LIB" >&2
	exit 1
fi

CONFIG_DIR="$ROOT_DIR/config"
REPOS_CONF="$CONFIG_DIR/repos.conf"
SEARCH_CONF="$CONFIG_DIR/search.conf"

usage() {
	cat <<EOF
Usage: eaw init
  eaw feature <CARD> "<TITLE>"
  eaw spike  <CARD> "<TITLE>"
  eaw bug    <CARD> "<TITLE>"
  eaw analyze <CARD>
  eaw ingest <CARD> <file-path>
EOF
}

cmd_init() {
	ensure_dir "$CONFIG_DIR"
	if [[ -f "$SCRIPT_DIR/sync-repos-config.sh" ]]; then
		bash "$SCRIPT_DIR/sync-repos-config.sh"
	else
		if [[ ! -f "$REPOS_CONF" ]]; then
			cp "$CONFIG_DIR/repos.example.conf" "$REPOS_CONF"
			echo "Created $REPOS_CONF"
		else
			echo "$REPOS_CONF already exists; skipping"
		fi
	fi
	if [[ ! -f "$SEARCH_CONF" ]]; then
		cp "$CONFIG_DIR/search.example.conf" "$SEARCH_CONF"
		echo "Created $SEARCH_CONF"
	else
		echo "$SEARCH_CONF already exists; skipping"
	fi
}

# --- Execution lifecycle engine -------------------------------------------------
run_phase() {
	# run_phase <phase-name> <fatal:true|false> <fn> [args...]
	local phase="$1"
	shift
	local fatal="$1"
	shift || true
	local fn="$1"
	shift
	local start end dur rc status
	local note=""
	start=$(date +%s%3N)
	if "$fn" "$@"; then
		rc=0
		status="OK"
	else
		rc=$?
		status="FAIL"
	fi
	end=$(date +%s%3N)
	dur=$((end - start))
	# record to execution log
	printf "%s|%s|%s|%s\n" "$phase" "$status" "$dur" "$note" >>"$OUTDIR/execution.log"
	# print summary line
	echo "[phase] $phase -> $status (${dur}ms)"
	if [[ "$status" != "OK" && "$fatal" == "true" ]]; then
		echo "phase '$phase' failed (fatal) with rc=$rc" >&2
		return "$rc"
	fi
	return 0
}

phase_init_runtime() {
	# $1 = type, $2 = card, $3 = title, $4 = outdir
	local type="$1" card="$2" title="$3" outdir="$4"
	# deterministic runtime for phases
	export LC_ALL=C
	export TZ=UTC
	ensure_dir "$outdir"
	local tpl
	tpl="$ROOT_DIR/templates/$(echo "$type" | tr '[:upper:]' '[:lower:]').md"
	if [[ ! -f "$tpl" ]]; then
		echo "Template not found: $tpl" >&2
		return 1
	fi
	local date
	date=$(iso_date)
	local target_md="$outdir/${type}_${card}.md"
	render_template "$tpl" "$target_md" "$card" "$title" "$type" "$date"
	echo "Wrote $target_md"
	# initialize execution.log
	: >"$outdir/execution.log"
	printf "phase|status|duration_ms|note\n" >>"$outdir/execution.log"
	return 0
}

phase_load_config() {
	# verify minimal config presence; not fatal if repos.conf missing (best-effort)
	local outdir="$1"
	if [[ ! -f "$REPOS_CONF" ]]; then
		echo "Missing $REPOS_CONF; proceeding without repository context (best-effort)" >&2
		return 0
	fi
	return 0
}

phase_resolve_repos() {
	# build list of repo entries (key|path) into REPO_ENTRIES array
	REPO_ENTRIES=()
	if [[ -f "$REPOS_CONF" ]]; then
		while IFS= read -r line; do
			line="${line//$'\r'/}"
			if [[ -z "$line" || "$line" =~ ^\s*# ]]; then
				continue
			fi
			REPO_ENTRIES+=("$line")
		done <"$REPOS_CONF"
	fi
	return 0
}

phase_collect_context() {
	local card="$1" outdir="$2"
	# iterate resolved repos and gather context
	for entry in "${REPO_ENTRIES[@]:-}"; do
		IFS='|' read -r key path <<<"$entry"
		if [[ -z "$key" || -z "$path" ]]; then
			continue
		fi
		repoPath="$(resolve_repo_path "$path")"
		repoOutDir="$outdir/context/$key"
		ensure_dir "$repoOutDir"
		echo "Collecting context for $key -> $repoPath"
		# gather context; failures are tolerated and produce _warnings.txt within gather_context_for_repo
		if ! gather_context_for_repo "$key" "$repoPath" "$repoOutDir"; then
			echo "allowed to fail: gather_context_for_repo failed for $key (see $repoOutDir)" >>"$repoOutDir/_warnings.txt"
		fi
	done
	return 0
}

phase_search_hits() {
	local outdir="$1"
	for entry in "${REPO_ENTRIES[@]:-}"; do
		IFS='|' read -r key path <<<"$entry"
		repoPath="$(resolve_repo_path "$path")"
		repoOutDir="$outdir/context/$key"
		if ! collect_search_hits "$key" "$repoPath" "$repoOutDir" "$SEARCH_CONF"; then
			echo "allowed to fail: collect_search_hits failed for $key (see $repoOutDir)" >>"$repoOutDir/_warnings.txt"
		fi
	done
	return 0
}

phase_finalize() {
	local card="$1" outdir="$2"
	# summarize execution.log to stdout
	if [[ -f "$outdir/execution.log" ]]; then
		echo "Execution log for $card:" >&2
		sed -n '1,200p' "$outdir/execution.log" >&2 || true
	fi
	return 0
}

# --- end lifecycle engine ----------------------------------------------------

cmd_card() {
	local type="$1"
	local card="$2"
	local title="$3"
	local outdir="$ROOT_DIR/out/$card"
	# expose OUTDIR for run_phase and others
	OUTDIR="$outdir"
	ensure_dir "$outdir"

	# run lifecycle phases in order; preserve original behavior and tolerances
	run_phase "init_runtime" true phase_init_runtime "$type" "$card" "$title" "$outdir" || return 1
	run_phase "load_config" false phase_load_config "$outdir"
	run_phase "resolve_repos" false phase_resolve_repos
	run_phase "collect_context" false phase_collect_context "$card" "$outdir"
	run_phase "search_hits" false phase_search_hits "$outdir"
	run_phase "finalize" false phase_finalize "$card" "$outdir"
}

cmd_analyze() {
	local card="$1"
	local outdir="$ROOT_DIR/out/$card"
	if [[ ! -d "$outdir" ]]; then
		echo "Card output not found: $outdir" >&2
		exit 1
	fi
	# detect type
	local type=""
	for t in feature spike bug; do
		if [[ -f "$outdir/${t}_${card}.md" ]]; then
			type="$t"
			break
		fi
	done
	if [[ -z "$type" ]]; then
		echo "Could not detect card type for $card. Expected feature/spike/bug file in $outdir" >&2
		exit 1
	fi

	local main_md="$outdir/${type}_${card}.md"
	if [[ ! -f "$main_md" ]]; then
		echo "Main dossier not found: $main_md" >&2
		exit 1
	fi

	ensure_dir "$outdir/inputs"

	# Build AI prompt
	local prompt_file="$outdir/AI_PROMPT_${card}.md"
	local date_now
	date_now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

	# collect repos list
	local repos_list
	if [[ -f "$REPOS_CONF" ]]; then
		repos_list=$(awk -F"|" '!/^\s*#/ && NF>=2 {print "- " $1 " => " $2}' "$REPOS_CONF")
	else
		repos_list="(no repos.conf present)"
	fi

	cat >"$prompt_file" <<EOF
# AI_PROMPT for card ${card}

ROLE:
You are a senior engineering analyst assisting with a structured review and mitigation plan for an engineering card. Provide concise, actionable analysis, tests, and a minimal change plan.

GUARDRAILS:
- Do not invent facts. Use only provided inputs and repository context.
- Mark assumptions explicitly.
- Prioritize minimal, safe fixes and clear test plans.

INPUTS:
- Dossier: $main_md
- Context directory: $outdir/context/
- Ingested files: $(ls -1 "$outdir/inputs" 2>/dev/null || echo "(none)")

REPOSITORIES:
$repos_list

PROCESS (mandatory 8 phases):
1) Understanding: Summarize card in 2-3 sentences.
2) Scoping: List affected modules and blast radius.
3) Evidence collection: Enumerate relevant files and diff snippets from context/.
4) Risk mapping: Map hotspots, regression risk, and critical paths.
5) Hypothesis & Proposed Fix: Describe minimal fix or experiment.
6) Test Plan: Provide deterministic tests and validation steps; produce TEST_PLAN file in dev/ (see Outputs).
7) Implementation steps: Minimal, atomic changes with rollbacks and feature flags where applicable.
8) Validation & Monitoring: Post-deploy checks, metrics to watch, and rollback criteria.

OUTPUTS (write to dev/ within the dossier output):
- TEST_PLAN_${card}.md - deterministic test plan (unit/integration/smoke)
- PATCH/PR summary (one paragraph)
- RISK_SUMMARY (one paragraph)

ALLOWED QUESTIONS (ask only when missing info):
- Are there existing failing tests related to this area?
- Is there any sensitive data or compliance constraint for changes?
- Any required stakeholders to involve?

Date generated: $date_now

-- Dossier content (begin) --

$(sed -n '1,400p' "$main_md")

-- Dossier content (end) --

EOF

	echo "Wrote $prompt_file"

	# create TEST_PLAN placeholder in outdir
	local test_plan="$outdir/TEST_PLAN_${card}.md"
	if [[ ! -f "$test_plan" ]]; then
		cat >"$test_plan" <<TP
# Test Plan for ${type}_${card}

## Summary

Describe deterministic tests to validate changes.

## Unit Tests

- Add tests for ...

## Integration Tests

- Run ...

TP
		echo "Wrote $test_plan"
	fi
}

cmd_ingest() {
	local card="$1"
	local src_path="$2"
	local outdir="$ROOT_DIR/out/$card"
	if [[ ! -f "$src_path" ]]; then
		echo "Source file not found: $src_path" >&2
		exit 1
	fi
	ensure_dir "$outdir/inputs"
	local fname
	fname=$(basename "$src_path")
	cp "$src_path" "$outdir/inputs/"
	echo "Copied $src_path -> $outdir/inputs/$fname"

	# update main dossier
	# detect type and main md
	local type=""
	for t in feature spike bug; do
		if [[ -f "$outdir/${t}_${card}.md" ]]; then
			type="$t"
			break
		fi
	done
	if [[ -z "$type" ]]; then
		echo "Cannot find main dossier to attach evidence: expected ${type}_${card}.md" >&2
		exit 1
	fi
	local main_md="$outdir/${type}_${card}.md"
	local ts
	ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)

	# insert or append Attached Evidence section
	if grep -q "^## Attached Evidence" "$main_md"; then
		# append bullet
		printf "- %s - %s\n" "$fname" "$ts" >>"$main_md"
	else
		printf "\n## Attached Evidence\n- %s - %s\n" "$fname" "$ts" >>"$main_md"
	fi
	echo "Registered evidence in $main_md"
}

main() {
	if [[ $# -lt 1 ]]; then
		usage
		exit 1
	fi
	case "$1" in
	init)
		cmd_init
		;;
	feature | spike | bug)
		if [[ $# -lt 3 ]]; then
			echo "Missing args" >&2
			usage
			exit 1
		fi
		cmd_card "${1}" "$2" "$3"
		;;
	analyze)
		if [[ $# -lt 2 ]]; then
			echo "Missing args" >&2
			usage
			exit 1
		fi
		cmd_analyze "$2"
		;;
	ingest)
		if [[ $# -lt 3 ]]; then
			echo "Missing args" >&2
			usage
			exit 1
		fi
		cmd_ingest "$2" "$3"
		;;
	--help | -h)
		usage
		exit 0
		;;
	*)
		usage
		exit 1
		;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
